import type { PlatformSpec } from 'react-native-nitro-modules'
import type { Language, Platform } from './getPlatformSpecs.js'
import type {
  InterfaceDeclaration,
  MethodSignature,
  ParameterDeclaration,
  PropertySignature,
  Type,
} from 'ts-morph'
import { ts } from 'ts-morph'
import { getNodeName } from './getNodeName.js'

interface File {
  name: string
  content: string
  language: Language
}

interface CodeNode {
  /**
   * Get the code of this code node (e.g. property, method) in the given language.
   */
  getCode(language: Language): string
  /**
   * Get all extra definition files this code node needs (e.g. extra type/struct declarations
   * for complex types), or `[]` if none are required (e.g. if this uses primitive types only)
   */
  getDefinitionFiles(language: Language): File[]
}

function createFileMetadataString(filename: string): string {
  const now = new Date()
  return `
///
/// ${filename}
/// ${now.toDateString()}
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/react-native-nitro
///
`
}

function capitalizeName(name: string): string {
  return name.charAt(0).toUpperCase() + name.slice(1)
}

function joinToIndented(array: string[], indentation: string = '    '): string {
  return array.join('\n').replaceAll('\n', `\n${indentation}`)
}

interface CppValueSignature {
  type: string
  name: string
}

interface CppMethodSignature {
  returnType: string
  rawName: string
  name: string
  parameters: CppValueSignature[]
  type: 'getter' | 'setter' | 'method'
}

class TSType implements CodeNode {
  readonly type: Type
  readonly isOptional: boolean
  private readonly cppName: string
  private readonly extraFiles: File[]

  private readonly baseTypes: TSType[]
  private readonly referencedTypes: TSType[]

  constructor(type: Type, isOptional: boolean) {
    this.type = type
    this.isOptional = isOptional
    this.baseTypes = []
    this.referencedTypes = []
    this.extraFiles = []

    if (type.isBigInt()) {
      this.cppName = 'int64_t'
    } else if (type.isBoolean()) {
      this.cppName = 'bool'
    } else if (type.isNull() || type.isUndefined()) {
      this.cppName = 'std::nullptr_t'
    } else if (type.isNumber()) {
      this.cppName = 'double'
    } else if (type.isString()) {
      this.cppName = 'std::string'
    } else if (type.isVoid()) {
      this.cppName = 'void'
    } else if (type.isObject() || type.isInterface()) {
      // It references another interface/type, either a simple struct, or another HybridObject
      const typename = type.getText()
      console.log(`ref: ${typename}`)

      const isHybridObject = type
        .getBaseTypes()
        .some((t) => t.getText().includes('HybridObject'))

      if (isHybridObject) {
        // It is another HybridObject being referenced!
        this.cppName = `std::shared_ptr<${typename}>`
      } else {
        // It is a simple struct being referenced.
        const cppProperties: CppValueSignature[] = []
        for (const prop of type.getProperties()) {
          // recursively resolve types for each property of the referenced type
          const declaration = prop.getValueDeclarationOrThrow()
          const propType = prop.getTypeAtLocation(declaration)
          const refType = new TSType(propType, prop.isOptional())
          cppProperties.push({ type: refType.getCode(), name: prop.getName() })
          this.referencedTypes.push(refType)
        }
        const cppStructProps = cppProperties.map((p) => `${p.type} ${p.name};`)
        const cppFromJsiProps = cppProperties.map(
          (p) =>
            `.${p.name} = JSIConverter<${p.type}>::fromJSI(runtime, obj.getProperty(runtime, "${p.name}")),`
        )
        const cppToJsiCalls = cppProperties.map(
          (p) =>
            `obj.setProperty(runtime, "${p.name}", JSIConverter<${p.type}>::toJSI(runtime, arg.${p.name}));`
        )
        const cppCode = `
${createFileMetadataString(`${typename}.hpp`)}

#pragma once

#include <NitroModules/JSIConverter.hpp>

struct ${typename} {
public:
  ${joinToIndented(cppStructProps, '  ')}
};

namespace margelo {

// ${typename} <> ${typename}
template <> struct JSIConverter<${typename}> {
  static ${typename} fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
    jsi::Object obj = arg.asObject(runtime);
    return ${typename} {
      ${joinToIndented(cppFromJsiProps, '      ')}
    };
  }
  static jsi::Value toJSI(jsi::Runtime& runtime, const ${typename}& arg) {
    jsi::Object obj(runtime);
    ${joinToIndented(cppToJsiCalls, '    ')}
    return obj;
  }
};

} // namespace margelo
        `
        this.extraFiles.push({
          language: 'c++',
          name: `${typename}.hpp`,
          content: cppCode,
        })
        this.cppName = typename
      }
    } else {
      throw new Error(
        `The TypeScript type "${type.getText()}" cannot be represented in C++!`
      )
    }
  }

  getCode(): string {
    if (this.isOptional) {
      return `std::optional<${this.cppName}>`
    } else {
      return this.cppName
    }
  }

  getDefinitionFiles(): File[] {
    const extra = this.extraFiles
    const inheritedDefinitionFiles = this.baseTypes.flatMap((b) =>
      b.getDefinitionFiles()
    )
    const referencedDefinitionFiles = this.referencedTypes.flatMap((r) =>
      r.getDefinitionFiles()
    )
    return [...extra, ...inheritedDefinitionFiles, ...referencedDefinitionFiles]
  }
}

class Property implements CodeNode {
  readonly name: string
  readonly type: TSType
  readonly isReadonly: boolean

  constructor(prop: PropertySignature) {
    this.name = getNodeName(prop)
    this.isReadonly = prop.hasModifier(ts.SyntaxKind.ReadonlyKeyword)
    const type = prop.getTypeNodeOrThrow().getType()
    const isOptional = prop.hasQuestionToken() || type.isNullable()
    this.type = new TSType(type, isOptional)
  }

  get cppSignatures(): CppMethodSignature[] {
    const signatures: CppMethodSignature[] = []
    const capitalizedName = capitalizeName(this.name)
    // getter
    signatures.push({
      returnType: this.type.getCode(),
      rawName: this.name,
      name: `get${capitalizedName}`,
      parameters: [],
      type: 'getter',
    })
    if (!this.isReadonly) {
      // setter
      signatures.push({
        returnType: 'void',
        rawName: this.name,
        name: `set${capitalizedName}`,
        parameters: [{ type: this.type.getCode(), name: this.name }],
        type: 'setter',
      })
    }
    return signatures
  }

  getDefinitionFiles(): File[] {
    return this.type.getDefinitionFiles()
  }

  getCode(language: Language): string {
    switch (language) {
      case 'c++':
        const signatures = this.cppSignatures
        const codeLines = signatures.map((s) => {
          const params = s.parameters.map((p) => `${p.type} ${p.name}`)
          return `virtual ${s.returnType} ${s.name}(${params.join(', ')}) = 0;`
        })
        return codeLines.join('\n')
      default:
        throw new Error(
          `Language ${language} is not yet supported for properties!`
        )
    }
  }
}

class Parameter implements CodeNode {
  readonly name: string
  readonly type: TSType

  constructor(param: ParameterDeclaration) {
    this.name = getNodeName(param)
    const type = param.getTypeNodeOrThrow().getType()
    const isOptional =
      param.hasQuestionToken() || param.isOptional() || type.isNullable()
    this.type = new TSType(type, isOptional)
  }

  get cppSignature(): CppValueSignature {
    return {
      name: this.name,
      type: this.type.getCode(),
    }
  }

  getCode(language: Language): string {
    switch (language) {
      case 'c++':
        const cppSignature = this.cppSignature
        return `${cppSignature.type} ${cppSignature.name}`
      default:
        throw new Error(
          `Language ${language} is not yet supported for parameters!`
        )
    }
  }

  getDefinitionFiles(): File[] {
    return this.type.getDefinitionFiles()
  }
}

class Method implements CodeNode {
  readonly name: string
  readonly returnType: TSType
  readonly parameters: Parameter[]

  constructor(prop: MethodSignature) {
    this.name = getNodeName(prop)
    const returnType = prop.getReturnTypeNodeOrThrow()
    const type = returnType.getType()
    const isOptional = type.isNullable()
    this.returnType = new TSType(type, isOptional)
    this.parameters = prop.getParameters().map((p) => new Parameter(p))
  }

  get cppSignature(): CppMethodSignature {
    return {
      rawName: this.name,
      name: this.name,
      returnType: this.returnType.getCode(),
      parameters: this.parameters.map((p) => p.cppSignature),
      type: 'method',
    }
  }

  getCode(language: Language): string {
    switch (language) {
      case 'c++':
        const signature = this.cppSignature
        const params = signature.parameters.map((p) => `${p.type} ${p.name}`)
        return `virtual ${signature.returnType} ${signature.name}(${params.join(', ')}) = 0;`
      default:
        throw new Error(
          `Language ${language} is not yet supported for property getters!`
        )
    }
  }

  getDefinitionFiles(): File[] {
    const parametersDefinitionFiles = this.parameters.flatMap((p) =>
      p.getDefinitionFiles()
    )
    const returnTypeDefinitionFiles = this.returnType.getDefinitionFiles()
    return [...returnTypeDefinitionFiles, ...parametersDefinitionFiles]
  }
}

export function createPlatformSpec<
  TPlatform extends Platform,
  TLanguage extends PlatformSpec[TPlatform],
>(
  module: InterfaceDeclaration,
  platform: TPlatform,
  language: TLanguage
): File[] {
  switch (platform) {
    case 'ios':
      switch (language) {
        case 'swift':
          return createAppleSwiftSpec(module)
        case 'c++':
          return createSharedCppSpec(module)
        default:
          throw new Error(`${language} is not supported on ${platform}!`)
      }
    case 'android':
      switch (language) {
        case 'kotlin':
          return createAndroidKotlinSpec(module)
        case 'c++':
          return createSharedCppSpec(module)
        default:
          throw new Error(`${language} is not supported on ${platform}!`)
      }
    default:
      throw new Error(`${platform} is not supported!`)
  }
}

function createSharedCppSpec(module: InterfaceDeclaration): File[] {
  const moduleName = getNodeName(module)
  const cppClassName = `${moduleName}Spec`

  // Properties (getters + setters)
  const properties = module
    .getChildrenOfKind(ts.SyntaxKind.PropertySignature)
    .filter((p) => p.getFirstChildByKind(ts.SyntaxKind.FunctionType) == null)
  const cppProperties = properties.map((p) => new Property(p))

  // Functions
  const functions = module.getChildrenOfKind(ts.SyntaxKind.MethodSignature)
  const cppMethods = functions.map((f) => new Method(f))

  // Generate the full header / code
  const cppHeaderCode = `
${createFileMetadataString(`${cppClassName}.hpp`)}

#pragma once

#include <stddef.h>
#include <string.h>
#include <NitroModules/HybridObject.hpp>

class ${cppClassName}: public HybridObject {
  public:
    // Constructor
    explicit ${cppClassName}(): HybridObject(TAG) { }

  public:
    // Properties
    ${joinToIndented(cppProperties.map((p) => p.getCode('c++')))}

  public:
    // Methods
    ${joinToIndented(cppMethods.map((m) => m.getCode('c++')))}

  protected:
    // Tag for logging
    static constexpr auto TAG = "${moduleName}";

  private:
    // Hybrid Setup
    void loadHybridMethods() override;
};
    `

  // Each C++ method needs to be registered in the HybridObject - that's getters, setters and normal methods.
  const registrations: string[] = []
  const signatures = [
    ...cppProperties.flatMap((p) => p.cppSignatures),
    ...cppMethods.map((m) => m.cppSignature),
  ]
  for (const signature of signatures) {
    let registerMethod: string
    switch (signature.type) {
      case 'getter':
        registerMethod = 'registerHybridGetter'
        break
      case 'setter':
        registerMethod = 'registerHybridSetter'
        break
      case 'method':
        registerMethod = 'registerHybridMethod'
        break
      default:
        throw new Error(`Invalid C++ Signature Type: ${signature.type}!`)
    }
    registrations.push(
      `${registerMethod}("${signature.rawName}", &${cppClassName}::${signature.name}, this);`
    )
  }

  const cppBodyCode = `
${createFileMetadataString(`${cppClassName}.cpp`)}

#include "${cppClassName}.hpp"

void ${cppClassName}::loadHybridMethods() {
  ${joinToIndented(registrations, '  ')}
}
    `

  const files: File[] = []
  files.push({
    content: cppHeaderCode,
    language: 'c++',
    name: `${cppClassName}.hpp`,
  })
  files.push({
    content: cppBodyCode,
    language: 'c++',
    name: `${cppClassName}.cpp`,
  })
  for (const prop of cppProperties) {
    // Add all files that the properties referenced
    for (const file of prop.getDefinitionFiles()) {
      files.push(file)
    }
  }
  for (const method of cppMethods) {
    // Add all files that the methods referenced
    for (const file of method.getDefinitionFiles()) {
      files.push(file)
    }
  }
  return files
}

function createAppleSwiftSpec(_module: InterfaceDeclaration): File[] {
  throw new Error(`Swift for Apple/iOS is not yet implemented!`)
}

function createAndroidKotlinSpec(_module: InterfaceDeclaration): File[] {
  throw new Error(`Kotlin for Android is not yet implemented!`)
}
